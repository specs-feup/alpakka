///////////////////////////////////////////////////
// This file is generated by build-interfaces.js //
///////////////////////////////////////////////////

/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-duplicate-type-constituents */

import {
  LaraJoinPoint,
  type JoinpointMapperType,
  registerJoinpointMapper,
  wrapJoinPoint,
  unwrapJoinPoint,
} from "@specs-feup/lara/api/LaraJoinPoint.js";

type PrivateMapper = {
  "Joinpoint": typeof Joinpoint,
  "ClassNode": typeof ClassNode,
  "Expression": typeof Expression,
  "FieldNode": typeof FieldNode,
  "FieldReference": typeof FieldReference,
  "LabelReference": typeof LabelReference,
  "Literal": typeof Literal,
  "Manifest": typeof Manifest,
  "MethodNode": typeof MethodNode,
  "MethodPrototype": typeof MethodPrototype,
  "MethodReference": typeof MethodReference,
  "Placeholder": typeof Placeholder,
  "PrimitiveLiteral": typeof PrimitiveLiteral,
  "Program": typeof Program,
  "RegisterList": typeof RegisterList,
  "RegisterRange": typeof RegisterRange,
  "RegisterReference": typeof RegisterReference,
  "ResourceNode": typeof ResourceNode,
  "SparseSwitchElement": typeof SparseSwitchElement,
  "Statement": typeof Statement,
  "TypeDescriptor": typeof TypeDescriptor,
  "ArrayType": typeof ArrayType,
  "Catch": typeof Catch,
  "ClassType": typeof ClassType,
  "Instruction": typeof Instruction,
  "Label": typeof Label,
  "LineDirective": typeof LineDirective,
  "PackedSwitch": typeof PackedSwitch,
  "PrimitiveType": typeof PrimitiveType,
  "RegistersDirective": typeof RegistersDirective,
  "ReturnStatement": typeof ReturnStatement,
  "SparseSwitch": typeof SparseSwitch,
  "Switch": typeof Switch,
  "ThrowStatement": typeof ThrowStatement,
  "Goto": typeof Goto,
  "IfComparison": typeof IfComparison,
  "IfComparisonWithZero": typeof IfComparisonWithZero,
};

type DefaultAttributeMap = {
}

export class Joinpoint extends LaraJoinPoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  /**
   * String representation of the ast
   */
  get ast(): string { return wrapJoinPoint(this._javaObject.getAst()) }
  /**
   * Returns an array with the children of the node, ignoring null nodes
   */
  get children(): Joinpoint[] { return wrapJoinPoint(this._javaObject.getChildren()) }
  /**
   * String with the code represented by this node
   */
  get code(): string { return wrapJoinPoint(this._javaObject.getCode()) }
  /**
   * Retrieves all descendants of the join point
   */
  get descendants(): Joinpoint[] { return wrapJoinPoint(this._javaObject.getDescendants()) }
  /**
   * The id of the node
   */
  get id(): string { return wrapJoinPoint(this._javaObject.getId()) }
  /**
   * Returns the parent node in the AST, or undefined if it is the root node
   */
  get parent(): Joinpoint { return wrapJoinPoint(this._javaObject.getParent()) }
  /**
   * Returns the 'program' joinpoint
   */
  get root(): Program { return wrapJoinPoint(this._javaObject.getRoot()) }
  /**
   * Looks for an ancestor joinpoint name, walking back on the AST
   */
  getAncestor(type: string): Joinpoint { return wrapJoinPoint(this._javaObject.getAncestor(unwrapJoinPoint(type))); }
  /**
   * Returns the child of the node at the given index, ignoring null nodes
   */
  getChild(index: number): Joinpoint { return wrapJoinPoint(this._javaObject.getChild(unwrapJoinPoint(index))); }
  /**
   * Retrieves the descendants of the given type
   */
  getDescendants(type: string): Joinpoint[] { return wrapJoinPoint(this._javaObject.getDescendants(unwrapJoinPoint(type))); }
  /**
   * Retrieves the descendants of the given type, including the node itself
   */
  getDescendantsAndSelf(type: string): Joinpoint[] { return wrapJoinPoint(this._javaObject.getDescendantsAndSelf(unwrapJoinPoint(type))); }
  /**
   * Removes the node associated to this joinpoint from the AST
   */
  detach(): Joinpoint { return wrapJoinPoint(this._javaObject.detach()); }
  /**
   * Inserts the given join point after this join point
   */
  insertAfter(node: Joinpoint): Joinpoint;
  /**
   * Overload which accepts a string
   */
  insertAfter(code: string): Joinpoint;
  /**
   * Inserts the given join point after this join point
   */
  insertAfter(p1: Joinpoint | string): Joinpoint { return wrapJoinPoint(this._javaObject.insertAfter(unwrapJoinPoint(p1))); }
  /**
   * Inserts the given join point before this join point
   */
  insertBefore(node: Joinpoint): Joinpoint;
  /**
   * Overload which accepts a string
   */
  insertBefore(node: string): Joinpoint;
  /**
   * Inserts the given join point before this join point
   */
  insertBefore(p1: Joinpoint | string): Joinpoint { return wrapJoinPoint(this._javaObject.insertBefore(unwrapJoinPoint(p1))); }
  /**
   * Replaces this node with the given node
   */
  replaceWith(node: Joinpoint): Joinpoint;
  /**
   * Overload which accepts a string
   */
  replaceWith(node: string): Joinpoint;
  /**
   * Overload which accepts a list of join points
   */
  replaceWith(node: Joinpoint[]): Joinpoint;
  /**
   * Replaces this node with the given node
   */
  replaceWith(p1: Joinpoint | string | Joinpoint[]): Joinpoint { return wrapJoinPoint(this._javaObject.replaceWith(unwrapJoinPoint(p1))); }
  /**
   * Overload which accepts a list of strings
   */
  replaceWithStrings(node: string[]): Joinpoint { return wrapJoinPoint(this._javaObject.replaceWithStrings(unwrapJoinPoint(node))); }
}

  /**
   * Class definition
   */
export class ClassNode extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get classDescriptor(): ClassType { return wrapJoinPoint(this._javaObject.getClassDescriptor()) }
  get fields(): FieldNode[] { return wrapJoinPoint(this._javaObject.getFields()) }
  get methods(): MethodNode[] { return wrapJoinPoint(this._javaObject.getMethods()) }
  get superClassDescriptor(): ClassType { return wrapJoinPoint(this._javaObject.getSuperClassDescriptor()) }
}

  /**
   * Expression
   */
export class Expression extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Field definition
   */
export class FieldNode extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get isStatic(): boolean { return wrapJoinPoint(this._javaObject.getIsStatic()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get referenceName(): string { return wrapJoinPoint(this._javaObject.getReferenceName()) }
}

  /**
   * Field reference
   */
export class FieldReference extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Label reference
   */
export class LabelReference extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get decl(): Label { return wrapJoinPoint(this._javaObject.getDecl()) }
}

  /**
   * Literal
   */
export class Literal extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * The application's manifest
   */
export class Manifest extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get activities(): string[] { return wrapJoinPoint(this._javaObject.getActivities()) }
  get packageName(): string { return wrapJoinPoint(this._javaObject.getPackageName()) }
  get services(): string[] { return wrapJoinPoint(this._javaObject.getServices()) }
}

  /**
   * Method definition
   */
export class MethodNode extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get isStatic(): boolean { return wrapJoinPoint(this._javaObject.getIsStatic()) }
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get prototype(): MethodPrototype { return wrapJoinPoint(this._javaObject.getPrototype()) }
  get referenceName(): string { return wrapJoinPoint(this._javaObject.getReferenceName()) }
  get registersDirective(): RegistersDirective { return wrapJoinPoint(this._javaObject.getRegistersDirective()) }
}

  /**
   * Method prototype
   */
export class MethodPrototype extends Literal {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get parameters(): TypeDescriptor[] { return wrapJoinPoint(this._javaObject.getParameters()) }
  get returnType(): TypeDescriptor { return wrapJoinPoint(this._javaObject.getReturnType()) }
}

  /**
   * Method reference
   */
export class MethodReference extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
  get parentClassDescriptor(): TypeDescriptor { return wrapJoinPoint(this._javaObject.getParentClassDescriptor()) }
  get prototype(): MethodPrototype { return wrapJoinPoint(this._javaObject.getPrototype()) }
}

  /**
   * Placeholder node
   */
export class Placeholder extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get kind(): string { return wrapJoinPoint(this._javaObject.getKind()) }
}

  /**
   * Primitive literal
   */
export class PrimitiveLiteral extends Literal {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  setValue(value: string): string { return wrapJoinPoint(this._javaObject.setValue(unwrapJoinPoint(value))); }
}

  /**
   * App node
   */
export class Program extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get classes(): ClassNode[] { return wrapJoinPoint(this._javaObject.getClasses()) }
  get manifest(): Manifest { return wrapJoinPoint(this._javaObject.getManifest()) }
  buildApk(outputName: string): void { return wrapJoinPoint(this._javaObject.buildApk(unwrapJoinPoint(outputName))); }
}

  /**
   * Register list
   */
export class RegisterList extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Register range
   */
export class RegisterRange extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Register reference
   */
export class RegisterReference extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Resource nodes, like xml files are not being handled for now
   */
export class ResourceNode extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Sparse switch element
   */
export class SparseSwitchElement extends Expression {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get label(): LabelReference { return wrapJoinPoint(this._javaObject.getLabel()) }
}

  /**
   * Statement
   */
export class Statement extends Joinpoint {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get line(): LineDirective { return wrapJoinPoint(this._javaObject.getLine()) }
  get nextStatement(): Statement { return wrapJoinPoint(this._javaObject.getNextStatement()) }
  get prevStatement(): Statement { return wrapJoinPoint(this._javaObject.getPrevStatement()) }
}

  /**
   * Type descriptor
   */
export class TypeDescriptor extends Literal {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Array descriptor
   */
export class ArrayType extends TypeDescriptor {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Catch directive
   */
export class Catch extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get catch(): LabelReference { return wrapJoinPoint(this._javaObject.getCatch()) }
  get exception(): TypeDescriptor { return wrapJoinPoint(this._javaObject.getException()) }
  get tryEnd(): LabelReference { return wrapJoinPoint(this._javaObject.getTryEnd()) }
  get tryStart(): LabelReference { return wrapJoinPoint(this._javaObject.getTryStart()) }
}

  /**
   * Class descriptor
   */
export class ClassType extends TypeDescriptor {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get className(): string { return wrapJoinPoint(this._javaObject.getClassName()) }
  get decl(): ClassNode { return wrapJoinPoint(this._javaObject.getDecl()) }
  get packageName(): string { return wrapJoinPoint(this._javaObject.getPackageName()) }
}

  /**
   * Instruction
   */
export class Instruction extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get canThrow(): boolean { return wrapJoinPoint(this._javaObject.getCanThrow()) }
  get opCodeName(): string { return wrapJoinPoint(this._javaObject.getOpCodeName()) }
  get setsRegister(): boolean { return wrapJoinPoint(this._javaObject.getSetsRegister()) }
  get setsResult(): boolean { return wrapJoinPoint(this._javaObject.getSetsResult()) }
}

  /**
   * Label declaration
   */
export class Label extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get name(): string { return wrapJoinPoint(this._javaObject.getName()) }
}

  /**
   * Line directive
   */
export class LineDirective extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get value(): Literal { return wrapJoinPoint(this._javaObject.getValue()) }
}

  /**
   * Packed switch directive
   */
export class PackedSwitch extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Primitive descriptor
   */
export class PrimitiveType extends TypeDescriptor {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Registers directive
   */
export class RegistersDirective extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get type(): string { return wrapJoinPoint(this._javaObject.getType()) }
  get value(): PrimitiveLiteral { return wrapJoinPoint(this._javaObject.getValue()) }
}

  /**
   * Smali instruction formats 10x, 11x
   */
export class ReturnStatement extends Instruction {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Sparse switch directive
   */
export class SparseSwitch extends Statement {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Smali instruction format 31t
   */
export class Switch extends Instruction {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Smali instruction format 11x
   */
export class ThrowStatement extends Instruction {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
}

  /**
   * Smali instruction formats 10t, 20t, 30t
   */
export class Goto extends Instruction {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get label(): LabelReference { return wrapJoinPoint(this._javaObject.getLabel()) }
}

  /**
   * Smali instruction format 22t
   */
export class IfComparison extends Instruction {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get label(): LabelReference { return wrapJoinPoint(this._javaObject.getLabel()) }
}

  /**
   * Smali instruction format 21t
   */
export class IfComparisonWithZero extends Instruction {
  /**
   * @internal
   */
  static readonly _defaultAttributeInfo: {readonly map?: DefaultAttributeMap, readonly name: string | null, readonly type?: PrivateMapper, readonly jpMapper?: typeof JoinpointMapper} = {
    name: null,
  };
  get label(): LabelReference { return wrapJoinPoint(this._javaObject.getLabel()) }
}

const JoinpointMapper = {
  joinpoint: Joinpoint,
  classNode: ClassNode,
  expression: Expression,
  fieldNode: FieldNode,
  fieldReference: FieldReference,
  labelReference: LabelReference,
  literal: Literal,
  manifest: Manifest,
  methodNode: MethodNode,
  methodPrototype: MethodPrototype,
  methodReference: MethodReference,
  placeholder: Placeholder,
  primitiveLiteral: PrimitiveLiteral,
  program: Program,
  registerList: RegisterList,
  registerRange: RegisterRange,
  registerReference: RegisterReference,
  resourceNode: ResourceNode,
  sparseSwitchElement: SparseSwitchElement,
  statement: Statement,
  typeDescriptor: TypeDescriptor,
  arrayType: ArrayType,
  catch: Catch,
  classType: ClassType,
  instruction: Instruction,
  label: Label,
  lineDirective: LineDirective,
  packedSwitch: PackedSwitch,
  primitiveType: PrimitiveType,
  registersDirective: RegistersDirective,
  returnStatement: ReturnStatement,
  sparseSwitch: SparseSwitch,
  switch: Switch,
  throwStatement: ThrowStatement,
  goto: Goto,
  ifComparison: IfComparison,
  ifComparisonWithZero: IfComparisonWithZero,
};

let registered = false;
if (!registered) {
  registerJoinpointMapper(JoinpointMapper);
  registered = true;
}

